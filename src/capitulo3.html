<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Eduardo Barbosa">
    <meta property="og:type" content="article" />
    <meta property="og:title" content="" />
    <meta name="robots" content="nofollow" />
    <title>DDD Quickly - Introdução</title>
    <link rel="stylesheet" type="text/css" href="assets/styles.css">
</head>

<body>
    <div class="wrapper">
        <nav>
            <a href="capitulo2.html">&lt;&lt; Capítulo 2</a>
            <a href="capitulo4.html">Capítulo 4 >></a>
        </nav>

        <main>
            <main>
                <article>
                    <h1>MODEL-DRIVEN DESIGN</h1>
                    <p>
                        Os capítulos anteriores ressaltaram a importância de uma abordagem de desenvolvimento de
                        software centrada no domínio de negócios. Dissemos que é fundamentalmente importante criar um
                        modelo que esteja profundamente enraizado no domínio, e deve refletir os conceitos essenciais do
                        domínio com grande precisão. A Linguagem Ubíqua deve ser totalmente exercitada durante todo o
                        processo de modelagem, a fim de facilitar a comunicação entre os especialistas em software e os
                        especialistas de domínio, e descobrir os principais conceitos de domínio que devem ser usados no
                        modelo. O objetivo deste processo de modelagem é criar um bom modelo. A próxima etapa é
                        implementar o modelo no código. Esta é uma fase igualmente importante do processo de
                        desenvolvimento de software. Ter criado um ótimo modelo, mas não transferi-lo adequadamente para
                        o código, acabará em um software de qualidade questionável.
                    </p>
                    <p>
                        Acontece que os analistas de software trabalham com especialistas do domínio de negócios por
                        meses, descobrem os elementos fundamentais do domínio, enfatizam as relações entre eles e criam
                        um modelo correto, que captura com precisão o domínio. Em seguida, o modelo é passado para os
                        desenvolvedores de software. Os desenvolvedores podem examinar o modelo e descobrir que alguns
                        dos conceitos ou relacionamentos encontrados nele não podem ser expressos adequadamente em
                        código. Então eles usam o modelo como a fonte original de inspiração, mas eles criam seu próprio
                        design que pega emprestado algumas das ideias do modelo e adiciona algumas ideias próprias. O
                        processo
                        de desenvolvimento continua e mais classes são adicionadas ao código, expandindo a divisão entre
                        o modelo original e a implementação final. O bom resultado final não é garantido. Bons
                        desenvolvedores podem criar um produto que funcione, mas ele resistirá às provações do tempo?
                        Será facilmente extensível? Será de fácil manutenção?
                    </p>
                    <p>
                        Qualquer domínio pode ser expresso com muitos modelos, e qualquer modelo pode ser expresso de
                        várias maneiras no código. Para cada problema específico pode haver mais de uma solução. Qual
                        escolhemos? Ter um modelo analiticamente correto não significa que o modelo possa ser expresso
                        diretamente em código. Ou talvez sua implementação quebre alguns princípios de design de
                        software, o que não é aconselhável. É importante escolher um modelo que possa ser colocado em
                        código com facilidade e precisão. A questão básica aqui é: como abordamos a transição do modelo
                        para o código?
                    </p>
                    <p>
                        Uma das técnicas de projeto recomendadas é o chamado <i>modelo de análise</i>, que é visto como
                        separado do projeto de código e geralmente é feito por pessoas diferentes. O modelo de análise é
                        o resultado da análise do domínio do negócio, resultando em um modelo que não leva em
                        consideração o software utilizado para implementação. Tal modelo é usado para entender o
                        domínio. Um certo nível de conhecimento é construído, e o modelo resultante pode ser
                        analiticamente correto. O software não é levado em consideração nesta fase porque é considerado
                        um fator de confusão. Este modelo chega aos desenvolvedores que devem fazer o design. Como o
                        modelo não foi construído com princípios de design em mente, provavelmente não servirá bem a
                        esse propósito. Os desenvolvedores terão que adaptá-lo ou criar um design separado. E não há
                        mais um mapeamento entre o modelo e o código. O resultado é que os modelos de análise são logo
                        abandonados após o início da codificação.
                    </p>
                    <p>
                        Um dos principais problemas com essa abordagem é que os analistas não podem prever alguns dos
                        defeitos em seu modelo e todas as complexidades do domínio. Os analistas podem ter entrado em
                        muitos detalhes com alguns dos componentes do modelo e não detalharam suficientemente outros.
                        Detalhes muito importantes são descobertos durante o processo de design e implementação. Um
                        modelo que seja verdadeiro para o domínio pode ter sérios problemas com a persistência do objeto
                        ou comportamento de desempenho inaceitável.
                    </p>
                    <p>
                        Os desenvolvedores serão forçados a tomar algumas decisões por conta própria e farão alterações
                        no design para resolver um problema real que não foi considerado quando o modelo foi criado.
                        Eles criam um design que se distancia do modelo, tornando-o menos relevante.
                    </p>
                    <p>
                        Se os analistas trabalharem de forma independente, eles acabarão criando um modelo. Quando esse
                        modelo é passado para os projetistas, parte do conhecimento dos analistas sobre o domínio e o
                        modelo é perdido. Embora o modelo possa ser expresso em diagramas e escrita, é provável que os
                        designers não compreendam todo o significado do modelo, ou os relacionamentos entre alguns
                        objetos ou seu comportamento. Existem detalhes em um modelo que não são facilmente expressos em
                        um diagrama, e podem não ser totalmente apresentados mesmo por escrito. Os desenvolvedores terão
                        dificuldade em entendê-los. Em alguns casos, eles farão algumas suposições sobre o comportamento
                        pretendido, e é possível que façam as erradas, resultando no funcionamento incorreto do
                        programa.
                    </p>
                    <p>
                        Os analistas têm suas próprias reuniões fechadas onde muitas coisas são discutidas sobre o
                        domínio e há muito compartilhamento de conhecimento. Eles criam um modelo que deveria conter
                        todas essas informações de forma condensada, e os desenvolvedores têm que assimilar tudo isso
                        lendo os documentos fornecidos a eles. Seria muito mais produtivo se os desenvolvedores pudessem
                        participar das reuniões de analistas e assim terem uma visão clara e completa do domínio e do
                        modelo antes de começarem a projetar o código.
                    </p>
                    <p>
                        Uma abordagem melhor é relacionar de perto a modelagem e o design de domínio. O modelo deve ser
                        construído de olho no software e nas considerações de projeto. Os desenvolvedores devem ser
                        incluídos no processo de modelagem. A ideia principal é escolher um modelo que possa ser
                        adequadamente expresso em software, para que o processo de projeto seja direto e baseado no
                        modelo. Relacionar firmemente o código a um modelo subjacente dá significado ao código e torna o
                        modelo relevante.
                    </p>
                    <p>
                        Envolver os desenvolvedores fornece feedback. Ele garante que o modelo possa ser implementado em
                        software. Se algo está errado, é identificado em um estágio inicial e o problema pode ser
                        facilmente corrigido.
                    </p>
                    <p>
                        Aqueles que escrevem o código devem conhecer muito bem o modelo e devem se sentir responsáveis
                        por sua integridade. Eles devem perceber que uma mudança no código implica uma mudança no
                        modelo; caso contrário, eles irão refatorar o código até o ponto em que ele não mais expresse o
                        modelo original. Se o analista se desvincular do processo de implementação, logo perderá a
                        preocupação com as limitações introduzidas pelo desenvolvimento. O resultado é um modelo que não
                        é prático.
                    </p>
                    <p>
                        Qualquer pessoa técnica que contribua para o modelo deve passar algum tempo tocando o código,
                        qualquer que seja o papel principal que desempenha no projeto. Qualquer pessoa responsável por
                        alterar o código deve aprender a expressar um modelo por meio do código. Todo desenvolvedor deve
                        estar envolvido em algum nível de discussão sobre o modelo e ter contato com especialistas do
                        domínio. Aqueles que contribuem de diferentes maneiras devem conscientemente engajar aqueles que
                        tocam o código em uma troca dinâmica de ideias-modelo por meio da Linguagem Ubíqua.
                    </p>
                    <p>
                        Se o design, ou alguma parte central dele, não for mapeado para o modelo de domínio, esse modelo
                        é de pouco valor e a correção do software é suspeita. Ao mesmo tempo, mapeamentos complexos
                        entre modelos e funções de design são difíceis de entender e, na prática, impossíveis de manter
                        à medida que o design muda. Abre-se uma divisão mortal entre análise e design, de modo que a
                        percepção obtida em cada uma dessas atividades não se alimente à outra.
                    </p>
                    <p>
                        Projete uma parte do sistema de software para refletir o modelo de domínio de maneira muito
                        literal, de modo que o mapeamento seja óbvio. Revisite o modelo e modifique-o para ser
                        implementado de forma mais natural no software, mesmo que você procure fazê-lo refletir uma
                        visão mais profunda do domínio. Exija um modelo único que atenda bem a ambos os propósitos, além
                        de suportar uma Linguagem Ubíqua fluente.
                    </p>
                    <p>
                        Extrair do modelo a terminologia usada no projeto e a atribuição básica de responsabilidades. O
                        código torna-se uma expressão do modelo, portanto, uma mudança no código pode ser uma mudança no
                        modelo. Seu efeito deve se propagar pelo resto das atividades do projeto de acordo.
                    </p>
                    <p>
                        Amarrar firmemente a implementação a um modelo geralmente requer ferramentas de desenvolvimento
                        de software e linguagens que suportem um paradigma de modelagem, como programação orientada a
                        objetos.
                    </p>
                    <p>
                        A programação orientada a objetos é adequada para implementação de modelos porque ambas são
                        baseadas no mesmo paradigma. A programação orientada a objetos fornece classes de objetos e
                        associações de classes, instâncias de objetos e mensagens entre eles. As linguagens OOP
                        possibilitam a criação de mapeamentos diretos entre objetos de modelo com seus relacionamentos e
                        suas contrapartes de programação.
                    </p>
                    <p>
                        As linguagens procedurais oferecem suporte limitado para design orientado por modelo. Essas
                        linguagens não oferecem as construções necessárias para implementar os principais componentes de
                        um modelo. Alguns dizem que OOP pode ser feito com uma linguagem procedural como C e, de fato,
                        algumas das funcionalidades podem ser reproduzidas dessa maneira. Os objetos podem ser simulados
                        como estruturas de dados. Tais estruturas não contêm o comportamento do objeto, e isso deve ser
                        adicionado separadamente como funções. O significado de tais dados existe apenas na mente do
                        desenvolvedor, porque o código em si não é explícito. Um programa escrito em uma linguagem
                        procedural geralmente é percebido como um conjunto de funções, uma chamando a outra e
                        trabalhando juntas para alcançar um determinado resultado. Tal programa não pode facilmente
                        encapsular conexões conceituais, tornando o mapeamento entre domínio e código difícil de ser
                        realizado.
                    </p>
                    <p>
                        Alguns domínios específicos, como a matemática, podem ser facilmente modelados e implementados
                        usando programação procedural, porque muitas teorias matemáticas são simplesmente abordadas
                        usando chamadas de função e estruturas de dados, pois trata-se principalmente de cálculos.
                        Domínios mais complexos não são apenas um conjunto de conceitos abstratos envolvendo
                        computações, e não podem ser reduzidos a um conjunto de algoritmos, de modo que linguagens
                        procedurais ficam aquém da tarefa de expressar os respectivos modelos. Por esse motivo, a
                        programação procedural não é recomendada para projetos orientados a modelos.
                    </p>

                    <h2>Os Blocos De Construção De Um Model-Driven Design</h2>
                    <p>
                        As seções a seguir deste capítulo apresentarão os padrões mais importantes a serem usados no
                        projeto orientado a modelos. O objetivo desses padrões é apresentar alguns dos elementos-chave
                        da modelagem de objetos e design de software do ponto de vista do design orientado a domínio. O
                        diagrama a seguir é um mapa dos padrões apresentados e as relações entre eles.
                    </p>
                    <img src="assets/03-01.JPG" width="531" title="img0301" />
                    <h2>Arquitetura em Camadas</h2>
                    <img src="assets/03-02.JPG" width="531" title="img0302" />
                    <p>
                        Quando criamos um aplicativo de software, grande parte do aplicativo não está diretamente
                        relacionado ao domínio, mas faz parte da infraestrutura ou atende ao próprio software. É
                        possível e ok que a parte de domínio de um aplicativo seja bem pequena em comparação com o
                        resto, já que um aplicativo típico contém muito código relacionado ao acesso ao banco de dados,
                        acesso a arquivos ou rede, interfaces de usuário, etc.
                    </p>
                    <p>
                        Em um programa orientado a objetos, a interface do usuário, o banco de dados e outros códigos de
                        suporte geralmente são gravados diretamente nos objetos de negócios. Lógica de negócios
                        adicional é incorporada no comportamento de widgets de interface do usuário e scripts de banco
                        de dados. Isso às vezes acontece porque é a maneira mais fácil de fazer as coisas funcionarem
                        rapidamente.
                    </p>
                    <p>
                        No entanto, quando o código relacionado ao domínio é misturado com as outras camadas, torna-se
                        extremamente difícil ver e pensar. Alterações superficiais na interface do usuário podem
                        realmente alterar a lógica de negócios. Alterar uma regra de negócios pode exigir rastreamento
                        meticuloso do código da interface do usuário, código do banco de dados ou outros elementos do
                        programa. A implementação de objetos coerentes e orientados por modelo torna-se impraticável. O
                        teste automatizado é complicado. Com todas as tecnologias e lógicas envolvidas em cada
                        atividade, um programa deve ser mantido muito simples ou se torna impossível de entender.
                    </p>
                    <p>
                        <b>Portanto</b>, particione um programa complexo em LAYERS. Desenvolva um design dentro de cada
                        LAYER que seja coeso e que dependa apenas das camadas abaixo. Siga os padrões de arquitetura
                        padrão para fornecer acoplamento flexível às camadas acima. Concentre todo o código relacionado
                        ao modelo de domínio em uma camada e isole-o da interface do usuário, do aplicativo e do código
                        de infraestrutura. Os objetos de domínio, livres da responsabilidade de se exibir, armazenar,
                        gerenciar tarefas do aplicativo e assim por diante, podem ser focados em expressar o modelo de
                        domínio. Isso permite que um modelo evolua para ser rico e claro o suficiente para capturar o
                        conhecimento essencial do negócio e colocá-lo em prática.
                    </p>
                    <p>
                        Uma solução de arquitetura comum para projetos orientados por domínio contém quatro camadas
                        conceituais:
                    </p>
                    <table>
                        <tr>
                            <td class="coluna-titulo"><b>User Interface (Camada de Apresentação)</b></td>
                            <td class="coluna-conteudo">Responsável por apresentar informações ao usuário e interpretar
                                comandos do usuário.</td>
                        </tr>
                        <tr>
                            <td class="coluna-titulo"><b>Application Layer</b></td>
                            <td class="coluna-conteudo">Esta é uma camada fina que coordena a atividade do aplicativo.
                                Ele não contém lógica de negócios. Ele não retém o estado dos objetos de negócios, mas
                                pode reter o estado do progresso de uma tarefa do aplicativo.</td>
                        </tr>
                        <tr>
                            <td class="coluna-titulo"><b>Domain Layer</b></td>
                            <td class="coluna-conteudo">Esta camada contém informações sobre o domínio. Este é o coração
                                do software empresarial. O estado dos objetos de negócios é mantido aqui. A persistência
                                dos objetos de negócios e possivelmente seu estado são delegados à camada de
                                infraestrutura.</td>
                        </tr>
                        <tr>
                            <td class="coluna-titulo"><b>Infrastructure Layer</b></td>
                            <td class="coluna-conteudo">Esta camada atua como uma biblioteca de suporte para todas as
                                outras camadas. Ele fornece comunicação entre camadas, implementa persistência para
                                objetos de negócios, contém bibliotecas de suporte para a camada de interface do
                                usuário, etc.</td>
                        </tr>
                    </table>
                    <br />
                    <p>
                        É importante dividir uma aplicação em camadas separadas e estabelecer regras de interação entre
                        as camadas. Se o código não estiver claramente separado em camadas, logo ficará tão emaranhado
                        que se tornará muito difícil gerenciar as alterações. Uma simples alteração em uma seção do
                        código pode ter resultados inesperados e indesejáveis em outras seções. A camada de domínio deve
                        ser focada em questões de domínio principal. Não deve estar envolvido em atividades de
                        infraestrutura. A interface do usuário não deve estar estreitamente conectada à lógica de
                        negócios nem às tarefas que normalmente pertencem à camada de infraestrutura. Uma camada de
                        aplicação é necessária em muitos casos. Tem que haver um gerente sobre a lógica de negócios que
                        supervisiona e coordena a atividade geral do aplicativo.
                    </p>
                    <p>
                        Por exemplo, uma interação típica do aplicativo, domínio e infraestrutura pode ser assim. O
                        usuário deseja reservar uma rota de voo e solicita que um serviço de aplicativo na camada de
                        aplicativo o faça. A camada de aplicativo busca os objetos de domínio relevantes da
                        infraestrutura e invoca métodos relevantes neles, por exemplo, para verificar as margens de
                        segurança de outros voos já reservados. Uma vez que os objetos de domínio tenham feito todas as
                        verificações e atualizado seu status para “decidido”, o serviço de aplicativo persiste os
                        objetos na infraestrutura.
                    </p>
                    <br />
                    <h2>Entidades</h2>
                    <p>
                        Há uma categoria de objetos que parecem ter uma identidade, que permanece a mesma em todos os
                        estados do software. Para esses objetos não são os atributos que importam, mas um fio de
                        continuidade e identidade, que abrange a vida de um sistema e pode se estender além dele. Tais
                        objetos são chamados de Entidades, as linguagens OOP mantêm instâncias de objetos na memória e
                        associam uma referência ou um endereço de memória para cada objeto. Essa referência é única para
                        cada objeto em um determinado momento, mas não há garantia de que permanecerá assim por um
                        período de tempo indefinido. Na verdade o contrário é verdade. Os objetos são constantemente
                        movidos para fora e de volta à memória, são serializados e enviados pela rede e recriados na
                        outra extremidade, ou são destruídos. Essa referência, que serve de identidade para o ambiente
                        de execução do programa, não é a identidade da qual estamos falando. Se houver uma classe que
                        contenha informações meteorológicas, como temperatura, é bem possível que haja duas instâncias
                        distintas da respectiva classe, ambas contendo o mesmo valor. Os objetos são perfeitamente
                        iguais e intercambiáveis ​​entre si, mas possuem referências diferentes. Não são entidades.
                    </p>
                    <p>
                        Se fôssemos implementar o conceito de Pessoa usando um programa de software, provavelmente
                        criaríamos uma classe Pessoa com uma série de atributos: nome, data de nascimento, local de
                        nascimento, etc. Algum desses atributos é a identidade da pessoa? ? O nome não pode ser a
                        identidade porque pode haver mais pessoas com o mesmo nome. Não poderíamos distinguir entre
                        pessoas com o mesmo nome, se tivéssemos em conta apenas o seu nome. Também não podemos usar data
                        de nascimento, porque muitas pessoas nascem no mesmo dia. O mesmo se aplica ao local de
                        nascimento. Um objeto deve ser diferenciado de outros objetos, mesmo que possam ter os mesmos
                        atributos. A identidade errada pode levar à corrupção de dados.
                    </p>
                    <p>
                        Considere um sistema de contabilidade bancária. Cada conta tem seu próprio número. Uma conta
                        pode ser identificada com precisão pelo seu número. Esse número permanece inalterado durante
                        toda a vida útil do sistema e garante a continuidade. O número da conta pode existir como um
                        objeto na memória ou pode ser destruído na memória e enviado ao banco de dados. Ele também pode
                        ser arquivado quando a conta é fechada, mas ainda existe em algum lugar, desde que haja algum
                        interesse em mantê-lo por perto. Não importa que representação seja necessária, o número
                        permanece o mesmo.
                    </p>
                    <p>
                        Portanto, implementar entidades em software significa criar identidade. Para uma pessoa pode ser
                        uma combinação de atributos: nome, data de nascimento, local de nascimento, nome dos pais,
                        endereço atual. O número do Seguro Social também é usado nos EUA para criar identidade. Para uma
                        conta bancária o número da conta parece ser suficiente para sua identidade. Normalmente a
                        identidade é um atributo do objeto, uma combinação de atributos, um atributo criado
                        especialmente para preservar e expressar a identidade, ou mesmo um comportamento. É importante
                        que dois objetos com identidades diferentes sejam facilmente distinguidos pelo sistema, e dois
                        objetos com a mesma identidade sejam considerados iguais pelo sistema. Se essa condição não for
                        atendida, todo o sistema pode ser corrompido.
                    </p>
                    <p>
                        Existem diferentes maneiras de criar uma identidade única para cada objeto. O ID pode ser gerado
                        automaticamente por um módulo e usado internamente no software sem torná-lo visível para o
                        usuário. Pode ser uma chave primária em uma tabela de banco de dados, que tem a garantia de ser
                        exclusiva no banco de dados. Sempre que o objeto é recuperado do banco de dados, seu ID é
                        recuperado e recriado na memória. O ID pode ser criado pelo usuário como acontece com os códigos
                        associados aos aeroportos. Cada aeroporto tem um identificador de string exclusivo que é
                        reconhecido internacionalmente e usado pelas agências de viagens em todo o mundo para
                        identificar aeroportos em seus horários de viagem. Outra solução é usar os atributos do objeto
                        para criar o ID, e quando isso não for suficiente, outro atributo pode ser adicionado para
                        ajudar a identificar o respectivo objeto.
                    </p>
                    <p>
                        Quando um objeto é distinguido por sua identidade, em vez de seus atributos, torne isso primário
                        em sua definição no modelo. Mantenha a definição de classe simples e focada na continuidade e
                        identidade do ciclo de vida. Defina um meio de distinguir cada objeto, independentemente de sua
                        forma ou história. Esteja alerta para os requisitos que exigem objetos correspondentes por
                        atributos. Defina uma operação que garanta a produção de um resultado exclusivo para cada
                        objeto, possivelmente anexando um símbolo com garantia de exclusividade. Este meio de
                        identificação pode vir de fora, ou pode ser um identificador arbitrário criado por e para o
                        sistema, mas deve corresponder às distinções de identidade no modelo. O modelo deve definir o
                        que significa ser a mesma coisa.
                    </p>
                    <p>
                        As entidades são objetos importantes de um modelo de domínio e devem ser consideradas desde o
                        início do processo de modelagem. Também é importante determinar se um objeto precisa ser uma
                        entidade ou não, o que é discutido no próximo padrão.
                    </p>
                    <br />
                    <h2>Value Objects</h2>
                    <p>

                    </p>
                    <p>
                        
                    </p>
                    <p>
                        
                    </p>
                    <p>
                        
                    </p>
                    <p>
                        
                    </p>
                    <p>
                        
                    </p>
                    <p>
                        
                    </p>
                    <p>
                        
                    </p>
                    <img src="assets/03-03.JPG" width="531" title="img0303" />
                    <p>
                        
                    </p>
                    <p>
                        
                    </p>
                </article>
            </main>
        </main>

        <nav>
            <a href="capitulo2.html">&lt;&lt; Capítulo 2</a>
            <a href="capitulo4.html">Capítulo 4 >></a>
        </nav>

        <footer>
            <p>
                This content is not licensed under a
                <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
            </p>
        </footer>
    </div>
</body>

</html>