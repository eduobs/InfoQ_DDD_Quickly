<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Eduardo Barbosa">
    <meta property="og:type" content="article" />
    <meta property="og:title" content="" />
    <meta name="robots" content="nofollow" />
    <title>DDD Quickly - Introdução</title>
    <link rel="stylesheet" type="text/css" href="assets/styles.css">
</head>

<body>
    <div class="wrapper">
        <nav>
            <a href="capitulo2.html">&lt;&lt; Capítulo 2</a>
            <a href="capitulo4.html">Capítulo 4 >></a>
        </nav>

        <main>
            <main>
                <article>
                    <h1>MODEL-DRIVEN DESIGN</h1>
                    <p>
                        Os capítulos anteriores ressaltaram a importância de uma abordagem de desenvolvimento de
                        software centrada no domínio de negócios. Dissemos que é fundamentalmente importante criar um
                        modelo que esteja profundamente enraizado no domínio, e deve refletir os conceitos essenciais do
                        domínio com grande precisão. A Linguagem Ubíqua deve ser totalmente exercitada durante todo o
                        processo de modelagem, a fim de facilitar a comunicação entre os especialistas em software e os
                        especialistas de domínio, e descobrir os principais conceitos de domínio que devem ser usados no
                        modelo. O objetivo deste processo de modelagem é criar um bom modelo. A próxima etapa é
                        implementar o modelo no código. Esta é uma fase igualmente importante do processo de
                        desenvolvimento de software. Ter criado um ótimo modelo, mas não transferi-lo adequadamente para
                        o código, acabará em um software de qualidade questionável.
                    </p>
                    <p>
                        Acontece que os analistas de software trabalham com especialistas do domínio de negócios por
                        meses, descobrem os elementos fundamentais do domínio, enfatizam as relações entre eles e criam
                        um modelo correto, que captura com precisão o domínio. Em seguida, o modelo é passado para os
                        desenvolvedores de software. Os desenvolvedores podem examinar o modelo e descobrir que alguns
                        dos conceitos ou relacionamentos encontrados nele não podem ser expressos adequadamente em
                        código. Então eles usam o modelo como a fonte original de inspiração, mas eles criam seu próprio
                        design que pega emprestado algumas das ideias do modelo e adiciona algumas ideias próprias. O
                        processo
                        de desenvolvimento continua e mais classes são adicionadas ao código, expandindo a divisão entre
                        o modelo original e a implementação final. O bom resultado final não é garantido. Bons
                        desenvolvedores podem criar um produto que funcione, mas ele resistirá às provações do tempo?
                        Será facilmente extensível? Será de fácil manutenção?
                    </p>
                    <p>
                        Qualquer domínio pode ser expresso com muitos modelos, e qualquer modelo pode ser expresso de
                        várias maneiras no código. Para cada problema específico pode haver mais de uma solução. Qual
                        escolhemos? Ter um modelo analiticamente correto não significa que o modelo possa ser expresso
                        diretamente em código. Ou talvez sua implementação quebre alguns princípios de design de
                        software, o que não é aconselhável. É importante escolher um modelo que possa ser colocado em
                        código com facilidade e precisão. A questão básica aqui é: como abordamos a transição do modelo
                        para o código?
                    </p>
                    <p>
                        Uma das técnicas de projeto recomendadas é o chamado <i>modelo de análise</i>, que é visto como
                        separado do projeto de código e geralmente é feito por pessoas diferentes. O modelo de análise é
                        o resultado da análise do domínio do negócio, resultando em um modelo que não leva em
                        consideração o software utilizado para implementação. Tal modelo é usado para entender o
                        domínio. Um certo nível de conhecimento é construído, e o modelo resultante pode ser
                        analiticamente correto. O software não é levado em consideração nesta fase porque é considerado
                        um fator de confusão. Este modelo chega aos desenvolvedores que devem fazer o design. Como o
                        modelo não foi construído com princípios de design em mente, provavelmente não servirá bem a
                        esse propósito. Os desenvolvedores terão que adaptá-lo ou criar um design separado. E não há
                        mais um mapeamento entre o modelo e o código. O resultado é que os modelos de análise são logo
                        abandonados após o início da codificação.
                    </p>
                    <p>
                        Um dos principais problemas com essa abordagem é que os analistas não podem prever alguns dos
                        defeitos em seu modelo e todas as complexidades do domínio. Os analistas podem ter entrado em
                        muitos detalhes com alguns dos componentes do modelo e não detalharam suficientemente outros.
                        Detalhes muito importantes são descobertos durante o processo de design e implementação. Um
                        modelo que seja verdadeiro para o domínio pode ter sérios problemas com a persistência do objeto
                        ou comportamento de desempenho inaceitável.
                    </p>
                    <p>
                        Os desenvolvedores serão forçados a tomar algumas decisões por conta própria e farão alterações
                        no design para resolver um problema real que não foi considerado quando o modelo foi criado.
                        Eles criam um design que se distancia do modelo, tornando-o menos relevante.
                    </p>
                    <p>
                        Se os analistas trabalharem de forma independente, eles acabarão criando um modelo. Quando esse
                        modelo é passado para os projetistas, parte do conhecimento dos analistas sobre o domínio e o
                        modelo é perdido. Embora o modelo possa ser expresso em diagramas e escrita, é provável que os
                        designers não compreendam todo o significado do modelo, ou os relacionamentos entre alguns
                        objetos ou seu comportamento. Existem detalhes em um modelo que não são facilmente expressos em
                        um diagrama, e podem não ser totalmente apresentados mesmo por escrito. Os desenvolvedores terão
                        dificuldade em entendê-los. Em alguns casos, eles farão algumas suposições sobre o comportamento
                        pretendido, e é possível que façam as erradas, resultando no funcionamento incorreto do
                        programa.
                    </p>
                    <p>
                        Os analistas têm suas próprias reuniões fechadas onde muitas coisas são discutidas sobre o
                        domínio e há muito compartilhamento de conhecimento. Eles criam um modelo que deveria conter
                        todas essas informações de forma condensada, e os desenvolvedores têm que assimilar tudo isso
                        lendo os documentos fornecidos a eles. Seria muito mais produtivo se os desenvolvedores pudessem
                        participar das reuniões de analistas e assim terem uma visão clara e completa do domínio e do
                        modelo antes de começarem a projetar o código.
                    </p>
                    <p>
                        Uma abordagem melhor é relacionar de perto a modelagem e o design de domínio. O modelo deve ser
                        construído de olho no software e nas considerações de projeto. Os desenvolvedores devem ser
                        incluídos no processo de modelagem. A ideia principal é escolher um modelo que possa ser
                        adequadamente expresso em software, para que o processo de projeto seja direto e baseado no
                        modelo. Relacionar firmemente o código a um modelo subjacente dá significado ao código e torna o
                        modelo relevante.
                    </p>
                    <p>
                        Envolver os desenvolvedores fornece feedback. Ele garante que o modelo possa ser implementado em
                        software. Se algo está errado, é identificado em um estágio inicial e o problema pode ser
                        facilmente corrigido.
                    </p>
                    <p>
                        Aqueles que escrevem o código devem conhecer muito bem o modelo e devem se sentir responsáveis
                        por sua integridade. Eles devem perceber que uma mudança no código implica uma mudança no
                        modelo; caso contrário, eles irão refatorar o código até o ponto em que ele não mais expresse o
                        modelo original. Se o analista se desvincular do processo de implementação, logo perderá a
                        preocupação com as limitações introduzidas pelo desenvolvimento. O resultado é um modelo que não
                        é prático.
                    </p>
                    <p>
                        Qualquer pessoa técnica que contribua para o modelo deve passar algum tempo tocando o código,
                        qualquer que seja o papel principal que desempenha no projeto. Qualquer pessoa responsável por
                        alterar o código deve aprender a expressar um modelo por meio do código. Todo desenvolvedor deve
                        estar envolvido em algum nível de discussão sobre o modelo e ter contato com especialistas do
                        domínio. Aqueles que contribuem de diferentes maneiras devem conscientemente engajar aqueles que
                        tocam o código em uma troca dinâmica de ideias-modelo por meio da Linguagem Ubíqua.
                    </p>
                    <p>
                        Se o design, ou alguma parte central dele, não for mapeado para o modelo de domínio, esse modelo
                        é de pouco valor e a correção do software é suspeita. Ao mesmo tempo, mapeamentos complexos
                        entre modelos e funções de design são difíceis de entender e, na prática, impossíveis de manter
                        à medida que o design muda. Abre-se uma divisão mortal entre análise e design, de modo que a
                        percepção obtida em cada uma dessas atividades não se alimente à outra.
                    </p>
                    <p>
                        Projete uma parte do sistema de software para refletir o modelo de domínio de maneira muito
                        literal, de modo que o mapeamento seja óbvio. Revisite o modelo e modifique-o para ser
                        implementado de forma mais natural no software, mesmo que você procure fazê-lo refletir uma
                        visão mais profunda do domínio. Exija um modelo único que atenda bem a ambos os propósitos, além
                        de suportar uma Linguagem Ubíqua fluente.
                    </p>
                    <p>
                        Extrair do modelo a terminologia usada no projeto e a atribuição básica de responsabilidades. O
                        código torna-se uma expressão do modelo, portanto, uma mudança no código pode ser uma mudança no
                        modelo. Seu efeito deve se propagar pelo resto das atividades do projeto de acordo.
                    </p>
                    <p>
                        Amarrar firmemente a implementação a um modelo geralmente requer ferramentas de desenvolvimento
                        de software e linguagens que suportem um paradigma de modelagem, como programação orientada a
                        objetos.
                    </p>
                    <p>
                        A programação orientada a objetos é adequada para implementação de modelos porque ambas são
                        baseadas no mesmo paradigma. A programação orientada a objetos fornece classes de objetos e
                        associações de classes, instâncias de objetos e mensagens entre eles. As linguagens OOP
                        possibilitam a criação de mapeamentos diretos entre objetos de modelo com seus relacionamentos e
                        suas contrapartes de programação.
                    </p>
                    <p>
                        As linguagens procedurais oferecem suporte limitado para design orientado por modelo. Essas
                        linguagens não oferecem as construções necessárias para implementar os principais componentes de
                        um modelo. Alguns dizem que OOP pode ser feito com uma linguagem procedural como C e, de fato,
                        algumas das funcionalidades podem ser reproduzidas dessa maneira. Os objetos podem ser simulados
                        como estruturas de dados. Tais estruturas não contêm o comportamento do objeto, e isso deve ser
                        adicionado separadamente como funções. O significado de tais dados existe apenas na mente do
                        desenvolvedor, porque o código em si não é explícito. Um programa escrito em uma linguagem
                        procedural geralmente é percebido como um conjunto de funções, uma chamando a outra e
                        trabalhando juntas para alcançar um determinado resultado. Tal programa não pode facilmente
                        encapsular conexões conceituais, tornando o mapeamento entre domínio e código difícil de ser
                        realizado.
                    </p>
                    <p>
                        Alguns domínios específicos, como a matemática, podem ser facilmente modelados e implementados
                        usando programação procedural, porque muitas teorias matemáticas são simplesmente abordadas
                        usando chamadas de função e estruturas de dados, pois trata-se principalmente de cálculos.
                        Domínios mais complexos não são apenas um conjunto de conceitos abstratos envolvendo
                        computações, e não podem ser reduzidos a um conjunto de algoritmos, de modo que linguagens
                        procedurais ficam aquém da tarefa de expressar os respectivos modelos. Por esse motivo, a
                        programação procedural não é recomendada para projetos orientados a modelos.
                    </p>

                    <h2>Os Blocos De Construção De Um Model-Driven Design</h2>
                    <p>
                        As seções a seguir deste capítulo apresentarão os padrões mais importantes a serem usados no
                        projeto orientado a modelos. O objetivo desses padrões é apresentar alguns dos elementos-chave
                        da modelagem de objetos e design de software do ponto de vista do design orientado a domínio. O
                        diagrama a seguir é um mapa dos padrões apresentados e as relações entre eles.
                    </p>
                    <img src="assets/03-01.JPG" width="531" title="img0301" />
                    <h2>Arquitetura em Camadas</h2>
                    <img src="assets/03-02.JPG" width="531" title="img0302" />
                    <p>
                        Quando criamos um aplicativo de software, grande parte do aplicativo não está diretamente
                        relacionado ao domínio, mas faz parte da infraestrutura ou atende ao próprio software. É
                        possível e ok que a parte de domínio de um aplicativo seja bem pequena em comparação com o
                        resto, já que um aplicativo típico contém muito código relacionado ao acesso ao banco de dados,
                        acesso a arquivos ou rede, interfaces de usuário, etc.
                    </p>
                    <p>
                        Em um programa orientado a objetos, a interface do usuário, o banco de dados e outros códigos de
                        suporte geralmente são gravados diretamente nos objetos de negócios. Lógica de negócios
                        adicional é incorporada no comportamento de widgets de interface do usuário e scripts de banco
                        de dados. Isso às vezes acontece porque é a maneira mais fácil de fazer as coisas funcionarem
                        rapidamente.
                    </p>
                    <p>
                        No entanto, quando o código relacionado ao domínio é misturado com as outras camadas, torna-se
                        extremamente difícil ver e pensar. Alterações superficiais na interface do usuário podem
                        realmente alterar a lógica de negócios. Alterar uma regra de negócios pode exigir rastreamento
                        meticuloso do código da interface do usuário, código do banco de dados ou outros elementos do
                        programa. A implementação de objetos coerentes e orientados por modelo torna-se impraticável. O
                        teste automatizado é complicado. Com todas as tecnologias e lógicas envolvidas em cada
                        atividade, um programa deve ser mantido muito simples ou se torna impossível de entender.
                    </p>
                    <p>
                        <b>Portanto</b>, particione um programa complexo em LAYERS. Desenvolva um design dentro de cada
                        LAYER que seja coeso e que dependa apenas das camadas abaixo. Siga os padrões de arquitetura
                        padrão para fornecer acoplamento flexível às camadas acima. Concentre todo o código relacionado
                        ao modelo de domínio em uma camada e isole-o da interface do usuário, do aplicativo e do código
                        de infraestrutura. Os objetos de domínio, livres da responsabilidade de se exibir, armazenar,
                        gerenciar tarefas do aplicativo e assim por diante, podem ser focados em expressar o modelo de
                        domínio. Isso permite que um modelo evolua para ser rico e claro o suficiente para capturar o
                        conhecimento essencial do negócio e colocá-lo em prática.
                    </p>
                    <p>
                        Uma solução de arquitetura comum para projetos orientados por domínio contém quatro camadas conceituais:
                    </p>
                    <table>
                        <tr>
                            <td><b>User Interface (Camada de Apresentação)</b></td>
                            <td>Responsável por apresentar informações ao usuário e interpretar comandos do usuário.</td>
                        </tr>
                        <tr>
                            <td><b>Application Layer</b></td>
                            <td>Esta é uma camada fina que coordena a atividade do aplicativo. Ele não contém lógica de negócios. Ele não retém o estado dos objetos de negócios, mas pode reter o estado do progresso de uma tarefa do aplicativo.</td>
                        </tr>
                        <tr>
                            <td><b>Domain Layer</b></td>
                            <td>Esta camada contém informações sobre o domínio. Este é o coração do software empresarial. O estado dos objetos de negócios é mantido aqui. A persistência dos objetos de negócios e possivelmente seu estado são delegados à camada de infraestrutura.</td>
                        </tr>
                        <tr>
                            <td><b>Infrastructure Layer</b></td>
                            <td>Esta camada atua como uma biblioteca de suporte para todas as outras camadas. Ele fornece comunicação entre camadas, implementa persistência para objetos de negócios, contém bibliotecas de suporte para a camada de interface do usuário, etc.</td>
                        </tr>
                    </table>
                </article>
            </main>
        </main>

        <nav>
            <a href="capitulo2.html">&lt;&lt; Capítulo 2</a>
            <a href="capitulo4.html">Capítulo 4 >></a>
        </nav>

        <footer>
            <p>
                This content is not licensed under a
                <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
            </p>
        </footer>
    </div>
</body>

</html>